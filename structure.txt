#!/usr/bin/env python3
import argparse
from pathlib import Path
import json
import numpy as np
import warnings
import os
import sys

# 保持与 eval_scannet.py 相同的导入风格，确保路径解析一致
ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
if ROOT_DIR not in sys.path:
    sys.path.insert(0, ROOT_DIR)

from vggt.utils.eval_utils import (
    get_sorted_image_paths,
    load_poses,
    build_frame_selection,
)


def _strictly_increasing(series):
    filtered = []
    discontinuities = []
    last = None
    for i, v in enumerate(series):
        if last is None or (v > last):
            filtered.append(v)
            last = v
        else:
            discontinuities.append(i)
    return np.asarray(filtered), discontinuities


def find_scene_dirs(root: Path):
    scenes = []
    for d in sorted(root.iterdir()):
        if d.is_dir() and d.name.startswith("scene") and (d / "metrics.json").exists():
            scenes.append(d)
    for sub in sorted(root.glob("input_frame_*/scene*")):
        if sub.is_dir() and (sub / "metrics.json").exists():
            scenes.append(sub)
    return scenes


def compute_and_print_fps(root: Path):
    scenes = find_scene_dirs(root)
    if not scenes:
        warnings.warn(
            f"在目录 {root} 下未发现包含 metrics.json 的场景目录",
            RuntimeWarning,
        )
    for scene_dir in scenes:
        mpath = scene_dir / "metrics.json"
        try:
            with open(mpath, "r") as f:
                metrics = json.load(f)
        except Exception as e:
            warnings.warn(f"读取 {mpath} 失败：{e}")
            continue

        scene_name = scene_dir.name

        inf_ms = metrics.get("inference_time_ms")
        if not isinstance(inf_ms, (int, float)):
            warnings.warn(f"{scene_name} 缺少有效 inference_time_ms，跳过")
            continue
        span_s = float(inf_ms) / 1000.0

        frame_count = None
        try:
            global _ARGS
            data_dir = _ARGS.data_dir if hasattr(_ARGS, "data_dir") else None
            input_frame = _ARGS.input_frame if hasattr(_ARGS, "input_frame") else 200
            if data_dir is not None and (data_dir / scene_name).exists():
                scene_root = data_dir / scene_name
                images_dir = scene_root / "color"
                pose_path = scene_root / "pose"
                image_paths = get_sorted_image_paths(images_dir)
                poses_gt, first_gt_pose, available_pose_frame_ids = load_poses(pose_path)
                if (
                    poses_gt is None
                    or first_gt_pose is None
                    or available_pose_frame_ids is None
                    or len(image_paths) == 0
                ):
                    raise RuntimeError("帧或位姿数据不足")
                selected_frame_ids, selected_image_paths, _ = build_frame_selection(
                    image_paths, available_pose_frame_ids, input_frame
                )
                frame_count = int(len(selected_image_paths))
            else:
                raise FileNotFoundError("未提供有效 data_dir 或场景目录不存在")
        except Exception as e:
            warnings.warn(f"{scene_name} 无法从数据集导入帧，改用近似：{e}")
            approx_frames = (
                metrics.get("n_frames")
                or metrics.get("frame_count")
                or metrics.get("num_frames")
            )
            if isinstance(approx_frames, (int, float)) and approx_frames > 0:
                frame_count = int(approx_frames)
            else:
                existing_fps = metrics.get("fps")
                if isinstance(existing_fps, (int, float)) and span_s > 0:
                    frame_count = int(round(existing_fps * span_s))
                else:
                    frame_count = None

        fps = (
            (float(frame_count) / span_s) if isinstance(frame_count, int) and span_s > 0 else None
        )

        frames_str = str(frame_count) if frame_count is not None else "NA"
        span_str = f"{span_s:.3f}" if isinstance(span_s, (int, float)) else "NA"
        fps_str = f"{float(fps):.3f}" if isinstance(fps, (int, float)) else "NA"
        print(
            f"Scene: {scene_name} | Frames: {frames_str} | Span(s): {span_str} | FPS: {fps_str}"
        )


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--results_dir",
        type=Path,
        default=Path(__file__).parent,
        help="包含场景 metrics.json 的目录（可为 input_frame_* 或 scene* 结构）",
    )
    parser.add_argument(
        "--data_dir",
        type=Path,
        default=Path("/home/jovyan/shared/xinzeli/scannetv2/process_scannet"),
        help="原始数据集根目录，包含 scene*/color 与 scene*/pose 子目录",
    )
    parser.add_argument(
        "--input_frame",
        type=int,
        default=200,
        help="按 eval_scannet.py 的筛选策略选取的最大帧数",
    )
    args = parser.parse_args()
    global _ARGS
    _ARGS = args
    try:
        import torch
        torch.manual_seed(33)
    except Exception:
        pass
    np.random.seed(0)
    compute_and_print_fps(args.results_dir)


if __name__ == "__main__":
    main()